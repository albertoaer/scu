use serde::{Serialize, Deserialize};

use crate::errors::{ScuError, self};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum Interpreter {
  Bash,
  Cmd,
  Batch, // Not generated by default
  Powershell,
  Python,
  Pythonw,
  Ruby,
}

impl Interpreter {
  pub fn all() -> [Self; 6] {
    [
      Self::Bash,
      Self::Cmd,
      Self::Python,
      Self::Pythonw,
      Self::Powershell,
      Self::Ruby,
    ]
  }

  pub fn from_name(name: impl AsRef<str>) -> Option<Self> {
    match name.as_ref().to_ascii_lowercase().as_str() {
      "bash" => Some(Self::Bash),
      "cmd" => Some(Self::Cmd),
      "batch" => Some(Self::Batch),
      "powershell" => Some(Self::Powershell),
      "python" => Some(Self::Python),
      "pythonw" => Some(Self::Pythonw),
      "ruby" => Some(Self::Ruby),
      _ => None
    }
  }

  pub fn from_extension(extension: impl AsRef<str>) -> Option<Self> {
    match extension.as_ref().to_ascii_lowercase().as_str() {
      ".sh" => Some(Self::Bash),
      ".cmd" => Some(Self::Cmd),
      ".bat" => Some(Self::Batch),
      ".ps1" => Some(Self::Powershell),
      ".py" => Some(Self::Python),
      ".pyw" => Some(Self::Pythonw),
      ".rb" => Some(Self::Ruby),
      _ => None
    }
  }

  pub fn name(&self) -> &'static str {
    match self {
      Self::Bash => "bash",
      Self::Cmd => "cmd",
      Self::Batch => "batch",
      Self::Powershell => "powershell",
      Self::Python => "python",
      Self::Pythonw => "pythonw",
      Self::Ruby => "ruby",
    }
  }

  pub fn extension(&self) -> &'static str {
    match self {
      Self::Bash => ".sh",
      Self::Cmd => ".cmd",
      Self::Batch => ".bat",
      Self::Python => ".py",
      Self::Pythonw => ".pyw",
      Self::Powershell => ".ps1",
      Self::Ruby => ".rb",
    }
  }

  pub fn prefer_no_extension(&self) -> bool {
    matches!(self, Self::Bash)
  }

  pub fn try_collect(interpreters: Option<&[impl AsRef<str>]>) -> errors::Result<Option<Vec<Interpreter>>> {
    match interpreters.and_then(
      |x| Some(x.iter().map(|x| x.as_ref().try_into()).collect::<errors::Result<Vec<Interpreter>>>())
    ) {
      Some(result) => result.map(|ok| Some(ok)),
      None => Ok(None),
    }
  }
}

impl TryFrom<&str> for Interpreter {
  type Error = ScuError;

  fn try_from(value: &str) -> Result<Self, Self::Error> {
    Self::from_name(value).ok_or(ScuError::StringError(format!("Interpreter not registered: {}", value)))
  }
}